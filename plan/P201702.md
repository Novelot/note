P201702
=
# 一. Android
1. Android启动过程
> 参考:http://blog.jobbole.com/67931/
- Linux内核的启动  
1. bootLoader->init进程  
2. ContextManager提供Android需要的系统服务  
3. Zygote派生出SystemServer  
```
ActivityThread

main(){
Looper.prepareMainLooper();
ActivityThread thread = new ActivityThread();
thread.attach(false);
Looper.loop();
}
```

2. Android架构

3. View的重绘时机(重走draw流程)
- invalidate()并不会走measure和layout流程,requestLayout()才会;
- setVisibility()
- setEnabled()
- setSelected()

4. View进行measure的时机
- 

5. 性能优化
- MAT
- DDMS
- ANR 
```
adb pull /data/anr/traces.txt
```
- adb pugreport

- 缓存
- 
6. 严苛模式
```
if (DEBUG_STRICT_MODE) {
	StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
			.detectDiskReads()
			.detectDiskWrites()
			.detectNetwork()   // or .detectAll() for all detectable problems
			.penaltyLog()
			.build());
	StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
			.detectLeakedSqlLiteObjects()
			.detectLeakedClosableObjects()
			.penaltyLog()
			.penaltyDeath()
			.build());
}
```
- android.os.StrictMode$StrictModeDiskReadViolation
- android.os.StrictMode$StrictModeNetworkViolation
- android.os.StrictMode$StrictModeCustomViolation

7. HandlerThread和Handler区别
- HandlerThread提供在非UI线程,进行线程通信的方法;
- 首先Handler和HandlerThread的主要区别是：Handler与Activity在同一个线程中，HandlerThread与Activity不在同一个线程，而是别外新的线程中(Handler中不能做耗时的操作)。
- 经典代码
```
    private static final HandlerThread sWorkerThread = new HandlerThread("launcher-loader");
    static {
        sWorkerThread.start();
    }
    private static final Handler sWorker = new Handler(sWorkerThread.getLooper());


 	public static void runOnWorkerThread(Runnable r) {
        if (sWorkerThread.getThreadId() == Process.myTid()) {
            r.run();
        } else {
            // If we are not on the worker thread, then post to the worker handler
            sWorker.post(r);
        }
    }
```

8. SystemClock类的方法
- System.currentTimeMillis()是一个标准的“墙”时钟(时间和日期)，表示从纪元到现在的毫秒数。该墙时钟能够被用户或电话网络(见setCurrentTimeMillis(long))设置，所以该时间可能会向前或向后不可预知地跳越。该时钟应该仅仅被使用在当现实世界的对应的日期和时间是重要的情况，例如一个日历或闹钟应用程序。而间隔时间和经过时间应该使用不同的时钟。如果你使用System.currentTimeMillis()，可以考虑监听ACTION为ACTION_TIME_TICK、 ACTION_TIME_CHANGED、ACTION_TIMEZONE_CHANGED 的广播去监听时间变化。
- SystemClock.uptimeMillis()表示自系统启动时开始计数，以毫秒为单位。返回的是从系统启动到现在这个过程中的处于非休眠期的时间。当系统进入深度睡眠时(CPU关闭，设备变黑，等待外部输入装置)该时钟会停止。但是该时钟不会被时钟调整，闲置或其他节能机所影响。这是大多数间隔时间的基本点，例如Thread.sleep(millls)、Object.wait(millis)和System.nanoTime()。该时钟被保证是单调的，适用于检测不包含休眠的间隔时间的情况。大多数的方法接受一个时间戳的值除了uptimeMillis()时钟。
- elapsedRealtime() and elapsedRealtimeNanos() 返回系统启动到现在的时间，包含设备深度休眠的时间。该时钟被保证是单调的，即使CPU在省电模式下，该时间也会继续计时。该时钟可以被使用在当测量时间间隔可能跨越系统睡眠的时间段。

9. AsyncTask和Handle的对比
- 
10. LurCache用法

# 二. Java
1. Thread和Runnable的 区别
- Runnable可以实现资源共享,Thread则不可以;
- Thread存在继承的局限,Runnable不存在;

2. 并发(多线程)
- 同步
- 生产者消费者
- 

# 三. 操作系统
1. 进程通信IPC 

# 四. 网络 
1. 各层数据结构   


|   层       |     数据单元      |     协议     |   职责  |  主要设备 |
|:------------:|:-------------------:|:--------------:|:---------:|:---------:|
|   应用层   |  message          |         Http/TELNET/FTP/XMPP/NNTP     |         |
|   传输层   |  Segment(数据段)  |    tcp/udp   |         |
|   网络层   |  Packet /Datagram |     ip/ICMP       |     (1)路由选路;(2)拥塞控制、差错检测与恢复;(3)网络互联     | 路由器 |
| 数据链路层 |  Frame            |  PPP            |     (1)数据链路的建立、维护、拆除、指定拓扑结构并提供硬件寻址;(2)数据组帧;(3)控制帧的收发顺序;(4)差错检测与恢复.流量控制    | 二层交换机\网桥
|   物理层   |  bit              |              |    (1)提供传输数据的物理通路;(2)传输数据       | 中继器\集线器|

   
# 五. 数据结构 

# 六. 算法 
1. KMP算法(字符串匹配算法)


# 七. 数据库 
 